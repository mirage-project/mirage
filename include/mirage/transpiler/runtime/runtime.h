// runtime.h - Runtime for Program Generated by Mirage
#pragma once

#include <vector>

#include <cuda_runtime.h>
#include <cuda_runtime_api.h>

#include <cute/layout.hpp>
#include <cute/tensor.hpp>
#include <cutlass/cutlass.h>

// The following two functions will be generated by the transpiler
static void _init();
static void _execute_mugraph(std::vector<void const *> input_tensors,
                             std::vector<void *> output_tensors,
                             std::vector<void *> comm_buffers,
                             void *buf,
                             cudaStream_t stream,
                             void *profiler_buffer);

// Runtime libraries
#include "config.h"
#include "kernel/element_binary.h"
#include "kernel/element_unary.h"
#include "kernel/matmul.h"
#include "kernel/reduction.h"
#include "kernel/communication.h"
#include "threadblock/threadblock.h"
#ifdef USE_NVSHMEM
#include "nvshmem_rt.h"
#include "threadblock/comm_executor.h"
#include "threadblock/allgather_host.h"
#endif
#include "utils.h"

// Entrypoint for C/C++
extern "C" void execute_mugraph(std::vector<void const *> input_tensors,
                                std::vector<void *> output_tensors,
                                std::vector<void *> comm_buffers,
                                void *buf,
                                cudaStream_t stream,
                                void *profiler_buffer) {

  static bool inited = false;
  if (!inited) {
    _init();
    inited = true;
  }
  _execute_mugraph(input_tensors, output_tensors, comm_buffers, buf, stream, profiler_buffer);
}

// A wrappr around `execute_mugraph` which uses C arrays instead of vectors
// Entrypoint for Python
void execute_mugraph_wrapper(void const *input_tensors[],
                             size_t num_input_tensors,
                             void *output_tensors[],
                             size_t num_output_tensors,
                             void *buf,
                             cudaStream_t stream,
                             void *profiler_buffer) {
  std::vector<void const *> input_tensors_vec(
      input_tensors, input_tensors + num_input_tensors);
  std::vector<void *> output_tensors_vec(output_tensors,
                                         output_tensors + num_output_tensors);
  std::vector<void *> comm_buffers;
  execute_mugraph(
      input_tensors_vec, output_tensors_vec, comm_buffers, buf, stream, profiler_buffer);
}

void execute_mugraph_wrapper(void const *input_tensors[],
                             size_t num_input_tensors,
                             void *output_tensors[],
                             size_t num_output_tensors,
                             void *comm_buffers[],
                             size_t num_comm_buffers,
                             void *buf) {
  std::vector<void const *> input_tensors_vec(
      input_tensors, input_tensors + num_input_tensors);
  std::vector<void *> output_tensors_vec(output_tensors,
                                         output_tensors + num_output_tensors);
  std::vector<void *> comm_buffers_vec(comm_buffers,
                                         comm_buffers + num_comm_buffers);
  cudaStream_t stream = 0;
  void *profiler_buffer = nullptr;
  execute_mugraph(input_tensors_vec, output_tensors_vec, comm_buffers_vec, buf, stream, profiler_buffer);
}