#pragma once

#include <condition_variable>
#include <mutex>
#include <queue>

namespace mirage {
namespace search {

template <typename T>
class WorkerQueue {
public:
  WorkerQueue(
      int num_thread,
      std::chrono::duration const &timeout = 5s)
      : queues(num_thread), mutexes(num_thread), timeout(timeout) {}

  void push(int thread_id, T const &value) {
    std::lock_guard<std::mutex> lock(mutexes[thread_id]);
    queues[thread_id].push(value);
    if (condition_to_steal(thread_id)) {
      conds[thread_id].notify_one();
    }
  }

  bool pop(int thread_id, T &value) {
    std::lock_guard<std::mutex> lock(mutexes[thread_id]);
    if (queues[thread_id].empty()) {
      if (!steal_tasks(thread_id)) {
        return false;
      }
    }
    value = queues[thread_id].front();
    queues[thread_id].pop();
    return true;
  }

private:
  bool condition_to_steal(int thread_id) const {
    return queues[thread_id].size() > 1000;
  }

  bool steal_tasks(int thread_id) {
    for (int i = 0; i < queues.size(); ++i) {
      if (try_steal(i, thread_id)) {
        return true;
      }
    }
    return false;
  }

  bool try_steal(int from_thread, int to_thread) {
    if (from_thread == to_thread) {
      return false;
    }
    if (mutexes[from_thread].try_lock_for(1ms)) {
      std::unique_lock lock(mutexes[from_thread], std::adopt_lock);
      if (!conds[from_thread].wait_for(lock, timeout, [this, from_thread] {
            return condition_to_steal(from_thread);
          })) {
        return false;
      }
      int half_size = queues[from_thread].size() / 2;
      for (int i = 0; i < half_size; ++i) {
        queues[to_thread].push(queues[from_thread].front());
        queues[from_thread].pop();
      }
    }
    return true;
  }

  std::vector<std::queue<T>> queues;
  std::vector<std::condition_variable> conds;
  std::vector<std::mutex> mutexes;
  std::chrono::duration timeout;
};

} // namespace search
} // namespace mirage